package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.TalonFXFeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

public class Arm extends SubsystemBase {
    /* Constants */
    /* CAN IDs */
    public final int PIVOT_TALON_FX_CAN_ID = 4;
    public final int EXTENDER_TALON_FX_CAN_ID = 5;

    /* PIDs */
    public final double PIVOT_KF = 0.0112d;
    public final double PIVOT_KP = 0.3d;
    public final double PIVOT_KI = 0.0d;
    public final double PIVOT_KD = 3d;

    public final double EXTENDER_KF = 0.0d;
    public final double EXTENDER_KP = 0.1d;
    public final double EXTENDER_KI = 0.001d;
    public final double EXTENDER_KD = 1d;

    /* Velocity */
    public final double PIVOT_MAX_VELOCITY = 3000d;
    public final double PIVOT_MAX_ACCELERATION = 2000d;
    public final double EXTENDER_MAX_VELOCITY = 30000d;
    public final double EXTENDER_MAX_ACCELERATION = 30000d;

    /* Motor constants */
    public final double MOTOR_NEUTRAL_DEADBAND = 0.001d;
    public final int PID_CONFIG_TIMEOUT_MS = 10;
    public final int CONFIG_ARM_FEEDBACKSENSOR_TIMEOUT_MS = 10;
    public final double CALIBRATION_MOTOR_SPEED = 0.1d;

    /* Conversion Factors */
    public final double ENCODER_UNITS_PER_REVOLUTION = 2048.0d / 1.0d;

    public final double PIVOT_GEARBOX_MOTOR_TO_GEARBOX_ARM_RATIO = 36.00d / 1.0d;
    public final double PIVOT_PULLEY_MOTOR_TO_PULLEY_ARM_RATIO = 36.00d / 72.0d;

    public final double EXTENDER_GEARBOX_MOTOR_TO_GEARBOX_ARM_RATIO = 4.0d / 1.0d;
    public final double EXTENDER_PULLEY_ROTATION_TO_INCHES = 3.75d; // One rotation of the final extender pulley moves the arm 3.75 inches 

    /* Physical constants */
    public final double ARM_PIVOT_OFFSET_X_INCHES = 17.0d; /* (0,0) is located at the floor to the center point of the robot */
    public final double ARM_PIVOT_OFFSET_Y_INCHES = 54.0d;
    public final double MIN_ANGLE_DEGREES = 0;
    public final double MAX_ANGLE_DEGREES = 110;
    public final double MIN_INCHES = 0; // TODO: FIND MINIMUM
    public final double MAX_INCHES = 1000; // TODO: FIND MAX    

    public final double ARM_X_DELTA_MODIFIER = 1.0d;
    public final double ARM_Y_DELTA_MODIFIER = 1.0d;

    public final double ZEROED_X_POSITION_INCHES = 0.0d; // TODO: Find X position when arm is zeroed!
    public final double ZEROED_Y_POSITION_INCHES = 15.0d; // TODO: Find Y position when arm is zeroed!
    
    /* Members */
    private WPI_TalonFX pivotTalonFX;
    private WPI_TalonFX extenderTalonFX;
    private double x;
    private double y;
    private boolean isCalibrated = false;

    // Gear ratios
    public Arm() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        pivotTalonFX = new WPI_TalonFX(PIVOT_TALON_FX_CAN_ID);
        extenderTalonFX = new WPI_TalonFX(EXTENDER_TALON_FX_CAN_ID);

        // Clears motor errors
        pivotTalonFX.clearStickyFaults();
        extenderTalonFX.clearStickyFaults();

        // Set factory defaults for onboard PID
        pivotTalonFX.configFactoryDefault();
        extenderTalonFX.configFactoryDefault();

        pivotTalonFX.configSelectedFeedbackSensor(TalonFXFeedbackDevice.IntegratedSensor, 0,
                CONFIG_ARM_FEEDBACKSENSOR_TIMEOUT_MS);
        extenderTalonFX.configSelectedFeedbackSensor(TalonFXFeedbackDevice.IntegratedSensor, 0,
                CONFIG_ARM_FEEDBACKSENSOR_TIMEOUT_MS);

        pivotTalonFX.setInverted(true);
        pivotTalonFX.setSensorPhase(true);
        extenderTalonFX.setInverted(false);
        extenderTalonFX.setSensorPhase(false);

        // Configure Position PID
        pivotTalonFX.config_kF(0, PIVOT_KF, PID_CONFIG_TIMEOUT_MS);
        pivotTalonFX.config_kP(0, PIVOT_KP, PID_CONFIG_TIMEOUT_MS);
        pivotTalonFX.config_kI(0, PIVOT_KI, PID_CONFIG_TIMEOUT_MS);
        pivotTalonFX.config_kD(0, PIVOT_KD, PID_CONFIG_TIMEOUT_MS);
        pivotTalonFX.config_IntegralZone(0, 1000);
        pivotTalonFX.configMotionCruiseVelocity(PIVOT_MAX_VELOCITY, PID_CONFIG_TIMEOUT_MS);
        pivotTalonFX.configMotionAcceleration(PIVOT_MAX_ACCELERATION, PID_CONFIG_TIMEOUT_MS);

        extenderTalonFX.config_kF(0, EXTENDER_KF, PID_CONFIG_TIMEOUT_MS);
        extenderTalonFX.config_kP(0, EXTENDER_KP, PID_CONFIG_TIMEOUT_MS);
        extenderTalonFX.config_kI(0, EXTENDER_KI, PID_CONFIG_TIMEOUT_MS);
        extenderTalonFX.config_kD(0, EXTENDER_KD, PID_CONFIG_TIMEOUT_MS);
        extenderTalonFX.config_IntegralZone(0, 100);
        extenderTalonFX.configMotionCruiseVelocity(EXTENDER_MAX_VELOCITY, PID_CONFIG_TIMEOUT_MS);
        extenderTalonFX.configMotionAcceleration(EXTENDER_MAX_ACCELERATION, PID_CONFIG_TIMEOUT_MS);

        extenderTalonFX.setNeutralMode(NeutralMode.Brake);
        pivotTalonFX.setNeutralMode(NeutralMode.Brake);

        extenderTalonFX.configNeutralDeadband(MOTOR_NEUTRAL_DEADBAND);
        pivotTalonFX.configNeutralDeadband(MOTOR_NEUTRAL_DEADBAND);
    }

    @Override
    public void periodic() {
        if(isCalibrated){
            moveToPosition(x, y);
        } else {
            /* Arm is not calibrated, do not attempt to move to a new position */
            checkCalibration();
        }
    }

    /**
     * Rotate the arm to a specific angle.
     * 
     * @param angle - the angle in radians
     */
    public void rotateTo(double radians) {
        final double maxRadians = Math.toRadians(MAX_ANGLE_DEGREES);
        final double minRadians = Math.toRadians(MIN_ANGLE_DEGREES);
        double encoderUnits = 0.0d;

        /* Clamp the value to the max or min if needed */
        radians = Math.max(Math.min(radians, maxRadians), minRadians);
        
        /* Convert radians to encoder units */
        encoderUnits = radians * (1.0d / ENCODER_UNITS_PER_REVOLUTION) * (1.0d / PIVOT_GEARBOX_MOTOR_TO_GEARBOX_ARM_RATIO) * (1.0d / PIVOT_PULLEY_MOTOR_TO_PULLEY_ARM_RATIO);

        pivotTalonFX.set(TalonFXControlMode.MotionMagic, encoderUnits);
    }


    /**
     * Extends arm to a given amount of inches.
     * 
     * @param length - the length to extend/retract to in inches
     */
    public void extendTo(double inches) {
        double encoderUnits = inches * EXTENDER_PULLEY_ROTATION_TO_INCHES * EXTENDER_GEARBOX_MOTOR_TO_GEARBOX_ARM_RATIO * ENCODER_UNITS_PER_REVOLUTION;

        extenderTalonFX.set(TalonFXControlMode.MotionMagic, encoderUnits);
    }

    /**
     * Moves the arm to a given position in space relative to the base.
     * 
     * @param targetX - position in inches
     * @param targetY - position in inches
     */
    public void moveToPosition(double targetX, double targetY) {
        double xDist = targetX - ARM_PIVOT_OFFSET_X_INCHES;
        double yDist = targetY - ARM_PIVOT_OFFSET_Y_INCHES;
        double length = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));
        double radians = Math.atan2(yDist, xDist);

        rotateTo(radians);
        extendTo(length);
    }

    /**
     * Sets the internal position of the arm.
     * 
     * @param xPos - position in inches
     * @param yPos - position in inches
     */
    public void setPosition(double xPos, double yPos) {
        x = xPos;
        y = yPos;
    }

    public void adjustPosition(double xPercentage, double yPercentage) {
        x += ARM_X_DELTA_MODIFIER * xPercentage;
        y += ARM_Y_DELTA_MODIFIER * yPercentage;
    }

    public void pivotZero() {
        pivotTalonFX.setSelectedSensorPosition(0);
    }

    public void extenderZero() {
        extenderTalonFX.setSelectedSensorPosition(0);
    }

    public void startCalibration() {
        isCalibrated = false;
        pivotTalonFX.set(-CALIBRATION_MOTOR_SPEED);
        extenderTalonFX.set(-CALIBRATION_MOTOR_SPEED);
    }

    private void checkCalibration() {
        boolean done = true;
        if (pivotTalonFX.isRevLimitSwitchClosed() == 1) {
            pivotTalonFX.set(0);
        } else {
            done = false;
        }

        if (extenderTalonFX.isRevLimitSwitchClosed() == 1) {
            extenderTalonFX.set(0);
        } else {
            done = false;
        }

        if(done) {
            /* Now that calibration is complete, we need to set the known position */
            setPosition(ZEROED_X_POSITION_INCHES, ZEROED_Y_POSITION_INCHES);
            isCalibrated = true;
        }
    }

    public boolean isCalibrated() {
        return (isCalibrated);
    }
}

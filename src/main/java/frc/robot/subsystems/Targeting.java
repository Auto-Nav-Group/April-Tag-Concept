// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;



// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Targeting extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private NetworkTable limeData;
    // t stands for target
    private NetworkTableEntry tAcquired;
    // x and y values of the target
    private NetworkTableEntry tx;
    private NetworkTableEntry ty;

    private double vF = 0.0;
    private double vP = 0.09;
    private double vI = 0.0;
    private double vD = 0.0;

    private double integral = 0.;
    private double TARGET_RIGHT_THRESHOLD = 1.0;
    private double TARGET_LEFT_THRESHOLD = -1.0;

    public Targeting() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        limeData = NetworkTableInstance.getDefault().getTable("limelight");
        tAcquired = limeData.getEntry("tv");
        tx = limeData.getEntry("tx");
        ty = limeData.getEntry("ty");

        limeData.getEntry("camMode").setNumber(0);
        


    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    // This method just returns whether it sees the target and it's x and y values
    public void controlLight(boolean enabled){
        if(enabled){
            limeData.getEntry("ledMode").setNumber(3);
        }
        else{
            limeData.getEntry("ledMode").setNumber(1);
        }
    }

    public double[] findTarget(){
        limeData.getEntry("ledMode").setNumber(3);
        double[] targetInfo = {tAcquired.getDouble(0.),tx.getDouble(0.),ty.getDouble(0.)};
        return targetInfo;
    }

    public double[] navToTarget(){
        limeData.getEntry("ledMode").setNumber(3);
        double[] velocityCommands = {0.0,0.0}; // Left motor velocity, Right motor velocity
        if (tAcquired.getDouble(0.0) == 1.0){
            double targetX = tx.getDouble(0.0);
            double error = Math.abs(targetX) - 0; // Error = Target - Actual
            vI += (error*.02); // Integral is increased by the error*time (which is .02 seconds using normal IterativeRobot)
            double rcw = vP*error + vI * this.integral;
            if(targetX > TARGET_RIGHT_THRESHOLD){
                velocityCommands[0] = -rcw;
                velocityCommands[1] = rcw;
            } else if(targetX < TARGET_LEFT_THRESHOLD){
                velocityCommands[0] = -rcw;
                velocityCommands[1] = rcw;
            } else {
                velocityCommands[0] = 0.0;
                velocityCommands[1] = 0.0;
            }
        }
        return velocityCommands;
    }

    

}


// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.RobotContainer;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import static frc.robot.Constants.LauncherConstants.*;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Launcher extends SubsystemBase 
{
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANT
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonFX m_launcherMotor;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private DoubleSolenoid m_m_shooterPiston;

    private double m_targetVelocity;

    /**
    *
    */
    public Launcher() 
    {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        m_launcherMotor = new WPI_TalonFX(6); 
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        DoubleSolenoid m_shooterPiston = new DoubleSolenoid(PISTON_MODULE_NUM, PISTON_FORWARD_CHANNEL, PISTON_REVERSE_CHANNEL);

        m_launcherMotor.clearStickyFaults();
        m_launcherMotor.configFactoryDefault();
        m_launcherMotor.configSelectedFeedbackSensor(FeedbackDevice.IntegratedSensor);
        m_launcherMotor.config_kF(PID_SLOT_ID, KF, PID_CONFIG_TIMEOUT_MS);
        m_launcherMotor.config_kP(PID_SLOT_ID, KP, PID_CONFIG_TIMEOUT_MS);
        m_launcherMotor.config_kI(PID_SLOT_ID, KI, PID_CONFIG_TIMEOUT_MS);
        m_launcherMotor.config_kD(PID_SLOT_ID, KD, PID_CONFIG_TIMEOUT_MS);
        m_launcherMotor.setInverted(true);
        m_launcherMotor.configClosedloopRamp(CLOSED_LOOP_RAMPRATE);

        m_targetVelocity = 0.0d;
    }

    @Override
    public void periodic() 
    {
        // Put code here to be run every loop
        // Update motor speed here IF SHOOTER IS ON
        
        if (newTargetRPM < 0)
        {
            System.out.println("Launcher - invalid targetRPM: " + newTargetRPM);
        } else
        {
            if (newTargetRPM != TARGET_RPM)
            {
                TARGET_RPM = newTargetRPM;
            }
        }

    }
    
    @Override
    public void simulationPeriodic() 
    {
        // This method will be called once per scheduler run when in simulation
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    //Converts RPMs to encoder units per desiseconds (100ms)
    private double convertRPMtoVelocity(double rpm) 
    {   
        return (rpm * GEAR_RATIO * ENCODER_UNITS_PER_REVOLUTION) / MINUTES_TO_DECISECONDS;
    }

    //Converys Encoder units per desiseconds (100ms) to RPMs
    private double convertVelocityToRPM(double velocity) 
    {
        return (velocity * MINUTES_TO_DECISECONDS) / (ENCODER_UNITS_PER_REVOLUTION * GEAR_RATIO);
    }

    // Sets launcher RMP to set RPM , used to turn on the launcher
    public void setLauncherRPM(double rpm) 
    {
        double velocity = convertRPMtoVelocity(rpm);
        m_launcherMotor.set(ControlMode.Velocity, velocity);
    }

    //Sets launcher RPM to 0, used to turn off the launcher
    public void disableLauncher() 
    {
        m_launcherMotor.set(0);
    }

    //Gets the current RPMs
    public double getCurrentRpm()
    {
        return convertVelocityToRPM(m_launcherMotor.getSelectedSensorVelocity(0));
    }

    //Determines if the launcher wheel is up to speed
    public boolean isReady() 
    {
        double currentRPM = getCurrentRpm();
        if (Math.abs(currentRPM - TARGET_DEADBAND) <= (TARGET_RPM)
        {
            SmartDashboard.putNumber("Current RPM", currentRPM);
            SmartDashboard.putBoolean("IsLauncherReady?", true);
            SmartDashboard.put
            return true;
        } 
        else 
        {
            SmartDashboard.putNumber("Current RPM", currentRPM);
            SmartDashboard.putBoolean("IsLauncherReady?", false);
            return false;
        }
    }

    public void dumbLauncher(){
        m_launcherMotor.set(0.9);
    }

    public void m_shooterPistonUp()
    {
        m_shooterPiston.set(Value.kForward);
    }

    public void m_shooterPistonDown()
    {
        m_shooterPiston.set(Value.kReverse);
    }
}
